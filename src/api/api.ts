/* tslint:disable */
/* eslint-disable */
/**
 * Trader API
 * API for the trading system
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface ATRIndicatorConfigDto
 */
export interface ATRIndicatorConfigDto {
    /**
     * Indicator type identifier.
     * @type {string}
     * @memberof ATRIndicatorConfigDto
     */
    'type': ATRIndicatorConfigDtoTypeEnum;
    /**
     * 
     * @type {ATROptionsDto}
     * @memberof ATRIndicatorConfigDto
     */
    'options': ATROptionsDto;
}

export const ATRIndicatorConfigDtoTypeEnum = {
    Atr: 'atr'
} as const;

export type ATRIndicatorConfigDtoTypeEnum = typeof ATRIndicatorConfigDtoTypeEnum[keyof typeof ATRIndicatorConfigDtoTypeEnum];

/**
 * 
 * @export
 * @interface ATROptionsDto
 */
export interface ATROptionsDto {
    /**
     * The period over which to calculate the ATR.
     * @type {number}
     * @memberof ATROptionsDto
     */
    'period': number;
}
/**
 * 
 * @export
 * @interface BollingerBandsIndicatorConfigDto
 */
export interface BollingerBandsIndicatorConfigDto {
    /**
     * Indicator type identifier.
     * @type {string}
     * @memberof BollingerBandsIndicatorConfigDto
     */
    'type': BollingerBandsIndicatorConfigDtoTypeEnum;
    /**
     * 
     * @type {BollingerBandsOptionsDto}
     * @memberof BollingerBandsIndicatorConfigDto
     */
    'options': BollingerBandsOptionsDto;
}

export const BollingerBandsIndicatorConfigDtoTypeEnum = {
    Bbands: 'bbands'
} as const;

export type BollingerBandsIndicatorConfigDtoTypeEnum = typeof BollingerBandsIndicatorConfigDtoTypeEnum[keyof typeof BollingerBandsIndicatorConfigDtoTypeEnum];

/**
 * 
 * @export
 * @interface BollingerBandsOptionsDto
 */
export interface BollingerBandsOptionsDto {
    /**
     * The look-back period for the moving average and standard deviation.
     * @type {number}
     * @memberof BollingerBandsOptionsDto
     */
    'period': number;
    /**
     * The number of standard deviations for the upper and lower bands.
     * @type {number}
     * @memberof BollingerBandsOptionsDto
     */
    'stdDev': number;
}
/**
 * 
 * @export
 * @interface BotEntityDto
 */
export interface BotEntityDto {
    /**
     * Unique identifier of the bot
     * @type {string}
     * @memberof BotEntityDto
     */
    'id': string;
    /**
     * Name of the bot/strategy
     * @type {string}
     * @memberof BotEntityDto
     */
    'name': string;
    /**
     * Description of the bot/strategy
     * @type {string}
     * @memberof BotEntityDto
     */
    'description': string;
    /**
     * ID of the user who owns this bot
     * @type {string}
     * @memberof BotEntityDto
     */
    'userId': string;
    /**
     * ID of the wallet to be used by the bot
     * @type {string}
     * @memberof BotEntityDto
     */
    'walletId': string;
    /**
     * List of market identifiers in the format \"BASE/QUOTE\" (e.g., \"SOL/USDC\")
     * @type {Array<string>}
     * @memberof BotEntityDto
     */
    'marketPairs': Array<string>;
    /**
     * Strategy configuration containing indicator and risk configurations
     * @type {StrategyConfigDto}
     * @memberof BotEntityDto
     */
    'strategyConfig': StrategyConfigDto;
    /**
     * ID of the market data feed to use
     * @type {string}
     * @memberof BotEntityDto
     */
    'marketDataFeedId': string;
    /**
     * Timestamp for when the bot was created
     * @type {string}
     * @memberof BotEntityDto
     */
    'createdAt': string;
    /**
     * Timestamp for when the bot was last updated
     * @type {string}
     * @memberof BotEntityDto
     */
    'updatedAt': string;
    /**
     * The current status of the bot
     * @type {BotStatus}
     * @memberof BotEntityDto
     */
    'status': BotStatus;
    /**
     * Stores the bot\'s status (e.g., ACTIVE, PAUSED) before a graceful shutdown process began.
     * @type {BotStatus}
     * @memberof BotEntityDto
     */
    'statusBeforeShutdown'?: BotStatus;
    /**
     * Defines how the bot should behave during a graceful system-initiated shutdown.
     * @type {GracefulShutdownAction}
     * @memberof BotEntityDto
     */
    'gracefulShutdownAction': GracefulShutdownAction;
}


/**
 * The current status of the bot
 * @export
 * @enum {string}
 */

export const BotStatus = {
    Active: 'active',
    Paused: 'paused',
    Stopped: 'stopped',
    Error: 'error',
    Persisting: 'persisting'
} as const;

export type BotStatus = typeof BotStatus[keyof typeof BotStatus];


/**
 * 
 * @export
 * @interface CreateBotDto
 */
export interface CreateBotDto {
    /**
     * Name of the bot/strategy
     * @type {string}
     * @memberof CreateBotDto
     */
    'name': string;
    /**
     * Description of the bot/strategy
     * @type {string}
     * @memberof CreateBotDto
     */
    'description': string;
    /**
     * User ID of the bot owner
     * @type {string}
     * @memberof CreateBotDto
     */
    'userId'?: string;
    /**
     * Optional ID of an existing wallet to use
     * @type {string}
     * @memberof CreateBotDto
     */
    'walletId'?: string;
    /**
     * 
     * @type {CreateBotDtoWalletConfig}
     * @memberof CreateBotDto
     */
    'walletConfig'?: CreateBotDtoWalletConfig;
    /**
     * List of market identifiers in the format \"BASE/QUOTE\" (e.g., \"SOL/USDC\")
     * @type {Array<string>}
     * @memberof CreateBotDto
     */
    'marketPairs': Array<string>;
    /**
     * Strategy configuration containing indicator and risk configurations
     * @type {StrategyConfigDto}
     * @memberof CreateBotDto
     */
    'strategyConfig': StrategyConfigDto;
    /**
     * Market data options for the bot
     * @type {MarketDataFeedOptionsDto}
     * @memberof CreateBotDto
     */
    'marketData'?: MarketDataFeedOptionsDto;
}
/**
 * @type CreateBotDtoWalletConfig
 * Wallet configuration for the bot
 * @export
 */
export type CreateBotDtoWalletConfig = InMemoryWalletConfigDto | SolanaWalletConfigDto;

/**
 * 
 * @export
 * @interface CreateMarketDataFeedDto
 */
export interface CreateMarketDataFeedDto {
    /**
     * Type of market data feed
     * @type {string}
     * @memberof CreateMarketDataFeedDto
     */
    'type': CreateMarketDataFeedDtoTypeEnum;
    /**
     * 
     * @type {CreateMarketDataFeedDtoOptions}
     * @memberof CreateMarketDataFeedDto
     */
    'options': CreateMarketDataFeedDtoOptions;
}

export const CreateMarketDataFeedDtoTypeEnum = {
    Simulation: 'simulation',
    Real: 'real',
    Historical: 'historical',
    Kinesis: 'kinesis'
} as const;

export type CreateMarketDataFeedDtoTypeEnum = typeof CreateMarketDataFeedDtoTypeEnum[keyof typeof CreateMarketDataFeedDtoTypeEnum];

/**
 * @type CreateMarketDataFeedDtoOptions
 * Configuration options for the market data feed, based on type
 * @export
 */
export type CreateMarketDataFeedDtoOptions = HistoricalMarketDataFeedConfigDto | KinesisMarketDataFeedConfigDto | RealMarketDataFeedConfigDto | SimulationMarketDataFeedConfigDto;

/**
 * 
 * @export
 * @interface CreatePortfolioDto
 */
export interface CreatePortfolioDto {
    /**
     * Portfolio name
     * @type {string}
     * @memberof CreatePortfolioDto
     */
    'name': string;
    /**
     * Detailed description of the portfolio
     * @type {string}
     * @memberof CreatePortfolioDto
     */
    'description': string;
    /**
     * ID of the user who owns this portfolio
     * @type {string}
     * @memberof CreatePortfolioDto
     */
    'userId': string;
    /**
     * ID of the wallet associated with this portfolio
     * @type {string}
     * @memberof CreatePortfolioDto
     */
    'walletId': string;
    /**
     * Optional set of bot IDs to associate with the portfolio
     * @type {Array<string>}
     * @memberof CreatePortfolioDto
     */
    'bots'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CreateUserDto
 */
export interface CreateUserDto {
    /**
     * The user\'s wallet public key
     * @type {string}
     * @memberof CreateUserDto
     */
    'walletPublicKey': string;
    /**
     * Optional portfolio ID to associate with this user
     * @type {string}
     * @memberof CreateUserDto
     */
    'portfolioId'?: string;
}
/**
 * 
 * @export
 * @interface CreateWalletDto
 */
export interface CreateWalletDto {
    /**
     * Name of the wallet (for identification)
     * @type {string}
     * @memberof CreateWalletDto
     */
    'name': string;
    /**
     * Optional description for the wallet
     * @type {string}
     * @memberof CreateWalletDto
     */
    'description'?: string;
    /**
     * Type of wallet
     * @type {string}
     * @memberof CreateWalletDto
     */
    'type': CreateWalletDtoTypeEnum;
    /**
     * 
     * @type {CreateWalletDtoOptions}
     * @memberof CreateWalletDto
     */
    'options': CreateWalletDtoOptions;
    /**
     * Snapshot configuration for the wallet
     * @type {WalletSnapshotConfigDto}
     * @memberof CreateWalletDto
     */
    'snapshotConfig'?: WalletSnapshotConfigDto;
}

export const CreateWalletDtoTypeEnum = {
    InMemory: 'in-memory',
    SolanaWallet: 'solana-wallet'
} as const;

export type CreateWalletDtoTypeEnum = typeof CreateWalletDtoTypeEnum[keyof typeof CreateWalletDtoTypeEnum];

/**
 * @type CreateWalletDtoOptions
 * Configuration options for the wallet, based on type
 * @export
 */
export type CreateWalletDtoOptions = InMemoryWalletOptionsDto | SolanaWalletOptionsDto;

/**
 * 
 * @export
 * @interface DEMAIndicatorConfigDto
 */
export interface DEMAIndicatorConfigDto {
    /**
     * The type of the indicator
     * @type {string}
     * @memberof DEMAIndicatorConfigDto
     */
    'type': DEMAIndicatorConfigDtoTypeEnum;
    /**
     * 
     * @type {DEMAOptionsDto}
     * @memberof DEMAIndicatorConfigDto
     */
    'options': DEMAOptionsDto;
}

export const DEMAIndicatorConfigDtoTypeEnum = {
    Dema: 'dema'
} as const;

export type DEMAIndicatorConfigDtoTypeEnum = typeof DEMAIndicatorConfigDtoTypeEnum[keyof typeof DEMAIndicatorConfigDtoTypeEnum];

/**
 * 
 * @export
 * @interface DEMAOptionsDto
 */
export interface DEMAOptionsDto {
    /**
     * The time period for the DEMA calculation
     * @type {number}
     * @memberof DEMAOptionsDto
     */
    'period': number;
}
/**
 * 
 * @export
 * @interface EMAConfigDto
 */
export interface EMAConfigDto {
    /**
     * Period for calculating the exponential moving average
     * @type {number}
     * @memberof EMAConfigDto
     */
    'period': number;
}
/**
 * 
 * @export
 * @interface EMAIndicatorConfigDto
 */
export interface EMAIndicatorConfigDto {
    /**
     * 
     * @type {string}
     * @memberof EMAIndicatorConfigDto
     */
    'type': EMAIndicatorConfigDtoTypeEnum;
    /**
     * Configuration options for the exponential moving average indicator
     * @type {EMAConfigDto}
     * @memberof EMAIndicatorConfigDto
     */
    'options': EMAConfigDto;
}

export const EMAIndicatorConfigDtoTypeEnum = {
    Ema: 'ema'
} as const;

export type EMAIndicatorConfigDtoTypeEnum = typeof EMAIndicatorConfigDtoTypeEnum[keyof typeof EMAIndicatorConfigDtoTypeEnum];

/**
 * Defines how the bot should behave during a graceful system-initiated shutdown.
 * @export
 * @enum {string}
 */

export const GracefulShutdownAction = {
    PauseOnly: 'pause_only'
} as const;

export type GracefulShutdownAction = typeof GracefulShutdownAction[keyof typeof GracefulShutdownAction];


/**
 * 
 * @export
 * @interface HistoricalMarketDataFeedConfigDto
 */
export interface HistoricalMarketDataFeedConfigDto {
    /**
     * Market pairs to track (e.g., [\"BTC/USDC\", \"SOL/USDC\"])
     * @type {Array<string>}
     * @memberof HistoricalMarketDataFeedConfigDto
     */
    'marketPairs': Array<string>;
    /**
     * Update frequency in milliseconds for fetching historical data
     * @type {number}
     * @memberof HistoricalMarketDataFeedConfigDto
     */
    'updateFrequency': number;
    /**
     * Start date for historical data backtesting
     * @type {string}
     * @memberof HistoricalMarketDataFeedConfigDto
     */
    'startDate': string;
    /**
     * End date for historical data backtesting
     * @type {string}
     * @memberof HistoricalMarketDataFeedConfigDto
     */
    'endDate': string;
    /**
     * Speed multiplier for replaying historical data (default: 1)
     * @type {number}
     * @memberof HistoricalMarketDataFeedConfigDto
     */
    'speedMultiplier'?: number;
    /**
     * Optional path to data file
     * @type {string}
     * @memberof HistoricalMarketDataFeedConfigDto
     */
    'dataPath'?: string;
}
/**
 * 
 * @export
 * @interface HistoricalMarketDataFeedDto
 */
export interface HistoricalMarketDataFeedDto {
    /**
     * Type of market data feed
     * @type {string}
     * @memberof HistoricalMarketDataFeedDto
     */
    'type': HistoricalMarketDataFeedDtoTypeEnum;
    /**
     * Configuration options for historical market data feed
     * @type {HistoricalMarketDataFeedConfigDto}
     * @memberof HistoricalMarketDataFeedDto
     */
    'options': HistoricalMarketDataFeedConfigDto;
}

export const HistoricalMarketDataFeedDtoTypeEnum = {
    Simulation: 'simulation',
    Real: 'real',
    Historical: 'historical',
    Kinesis: 'kinesis'
} as const;

export type HistoricalMarketDataFeedDtoTypeEnum = typeof HistoricalMarketDataFeedDtoTypeEnum[keyof typeof HistoricalMarketDataFeedDtoTypeEnum];

/**
 * 
 * @export
 * @interface InMemoryWalletConfigDto
 */
export interface InMemoryWalletConfigDto {
    /**
     * Type of wallet
     * @type {string}
     * @memberof InMemoryWalletConfigDto
     */
    'type': InMemoryWalletConfigDtoTypeEnum;
    /**
     * Configuration options for in-memory wallet
     * @type {InMemoryWalletOptionsDto}
     * @memberof InMemoryWalletConfigDto
     */
    'options': InMemoryWalletOptionsDto;
}

export const InMemoryWalletConfigDtoTypeEnum = {
    InMemory: 'in-memory'
} as const;

export type InMemoryWalletConfigDtoTypeEnum = typeof InMemoryWalletConfigDtoTypeEnum[keyof typeof InMemoryWalletConfigDtoTypeEnum];

/**
 * 
 * @export
 * @interface InMemoryWalletOptionsDto
 */
export interface InMemoryWalletOptionsDto {
    /**
     * Initial cash balance
     * @type {number}
     * @memberof InMemoryWalletOptionsDto
     */
    'initialCash'?: number;
}
/**
 * 
 * @export
 * @interface InsufficientCashRiskDto
 */
export interface InsufficientCashRiskDto {
    /**
     * 
     * @type {string}
     * @memberof InsufficientCashRiskDto
     */
    'type': InsufficientCashRiskDtoTypeEnum;
    /**
     * No additional options required for InsufficientCashRule
     * @type {object}
     * @memberof InsufficientCashRiskDto
     */
    'options'?: object;
}

export const InsufficientCashRiskDtoTypeEnum = {
    InsufficientCash: 'insufficientCash'
} as const;

export type InsufficientCashRiskDtoTypeEnum = typeof InsufficientCashRiskDtoTypeEnum[keyof typeof InsufficientCashRiskDtoTypeEnum];

/**
 * 
 * @export
 * @interface InsufficientHoldingsRiskDto
 */
export interface InsufficientHoldingsRiskDto {
    /**
     * 
     * @type {string}
     * @memberof InsufficientHoldingsRiskDto
     */
    'type': InsufficientHoldingsRiskDtoTypeEnum;
    /**
     * No additional options required for InsufficientHoldingsRule
     * @type {object}
     * @memberof InsufficientHoldingsRiskDto
     */
    'options'?: object;
}

export const InsufficientHoldingsRiskDtoTypeEnum = {
    InsufficientHoldings: 'insufficientHoldings'
} as const;

export type InsufficientHoldingsRiskDtoTypeEnum = typeof InsufficientHoldingsRiskDtoTypeEnum[keyof typeof InsufficientHoldingsRiskDtoTypeEnum];

/**
 * 
 * @export
 * @interface KinesisMarketDataFeedConfigDto
 */
export interface KinesisMarketDataFeedConfigDto {
    /**
     * Market pairs to track (e.g., [\"BTC/USDC\", \"SOL/USDC\"])
     * @type {Array<string>}
     * @memberof KinesisMarketDataFeedConfigDto
     */
    'marketPairs': Array<string>;
    /**
     * Update frequency in milliseconds for polling Kinesis
     * @type {number}
     * @memberof KinesisMarketDataFeedConfigDto
     */
    'updateFrequency': number;
    /**
     * Name of the Kinesis stream to consume from
     * @type {string}
     * @memberof KinesisMarketDataFeedConfigDto
     */
    'streamName': string;
    /**
     * AWS region where the Kinesis stream is located
     * @type {string}
     * @memberof KinesisMarketDataFeedConfigDto
     */
    'awsRegion'?: string;
    /**
     * Optional shard ID to consume from
     * @type {string}
     * @memberof KinesisMarketDataFeedConfigDto
     */
    'shardId'?: string;
    /**
     * Iterator type to start from (\'LATEST\' or \'TRIM_HORIZON\')
     * @type {string}
     * @memberof KinesisMarketDataFeedConfigDto
     */
    'shardIteratorType'?: KinesisMarketDataFeedConfigDtoShardIteratorTypeEnum;
}

export const KinesisMarketDataFeedConfigDtoShardIteratorTypeEnum = {
    Latest: 'LATEST',
    TrimHorizon: 'TRIM_HORIZON'
} as const;

export type KinesisMarketDataFeedConfigDtoShardIteratorTypeEnum = typeof KinesisMarketDataFeedConfigDtoShardIteratorTypeEnum[keyof typeof KinesisMarketDataFeedConfigDtoShardIteratorTypeEnum];

/**
 * 
 * @export
 * @interface MACDIndicatorConfigDto
 */
export interface MACDIndicatorConfigDto {
    /**
     * Indicator type identifier.
     * @type {string}
     * @memberof MACDIndicatorConfigDto
     */
    'type': MACDIndicatorConfigDtoTypeEnum;
    /**
     * 
     * @type {MACDOptionsDto}
     * @memberof MACDIndicatorConfigDto
     */
    'options': MACDOptionsDto;
}

export const MACDIndicatorConfigDtoTypeEnum = {
    Macd: 'macd'
} as const;

export type MACDIndicatorConfigDtoTypeEnum = typeof MACDIndicatorConfigDtoTypeEnum[keyof typeof MACDIndicatorConfigDtoTypeEnum];

/**
 * 
 * @export
 * @interface MACDOptionsDto
 */
export interface MACDOptionsDto {
    /**
     * Fast (short-term) EMA period.
     * @type {number}
     * @memberof MACDOptionsDto
     */
    'fastPeriod': number;
    /**
     * Slow (long-term) EMA period.
     * @type {number}
     * @memberof MACDOptionsDto
     */
    'slowPeriod': number;
    /**
     * Signal line EMA period (EMA of the MACD line).
     * @type {number}
     * @memberof MACDOptionsDto
     */
    'signalPeriod': number;
}
/**
 * 
 * @export
 * @interface MarketDataDto
 */
export interface MarketDataDto {
    /**
     * Market pair (containing base and quote symbols)
     * @type {MarketPairDto}
     * @memberof MarketDataDto
     */
    'marketPair': MarketPairDto;
    /**
     * Timestamp when the price was recorded (in milliseconds since epoch)
     * @type {number}
     * @memberof MarketDataDto
     */
    'timestamp': number;
    /**
     * OHLC data for different time periods, including both trailing and fixed interval data
     * @type {{ [key: string]: any; }}
     * @memberof MarketDataDto
     */
    'bars': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface MarketDataFeedEntityDto
 */
export interface MarketDataFeedEntityDto {
    /**
     * Unique identifier for the market data feed
     * @type {string}
     * @memberof MarketDataFeedEntityDto
     */
    'id': string;
    /**
     * Type of market data feed (simulation, real, historical)
     * @type {string}
     * @memberof MarketDataFeedEntityDto
     */
    'type': MarketDataFeedEntityDtoTypeEnum;
    /**
     * Name of the market data feed
     * @type {string}
     * @memberof MarketDataFeedEntityDto
     */
    'name'?: string;
    /**
     * Description of the market data feed
     * @type {string}
     * @memberof MarketDataFeedEntityDto
     */
    'description'?: string;
    /**
     * Configuration options specific to the type of market data feed
     * @type {{ [key: string]: any; }}
     * @memberof MarketDataFeedEntityDto
     */
    'options': { [key: string]: any; };
    /**
     * Whether this is the default market data feed
     * @type {boolean}
     * @memberof MarketDataFeedEntityDto
     */
    'isDefault': boolean;
    /**
     * User ID of the owner of this market data feed
     * @type {string}
     * @memberof MarketDataFeedEntityDto
     */
    'userId'?: string;
    /**
     * Timestamp when the market data feed was created
     * @type {string}
     * @memberof MarketDataFeedEntityDto
     */
    'createdAt': string;
    /**
     * Timestamp when the market data feed was last updated
     * @type {string}
     * @memberof MarketDataFeedEntityDto
     */
    'updatedAt': string;
}

export const MarketDataFeedEntityDtoTypeEnum = {
    Simulation: 'simulation',
    Real: 'real',
    Historical: 'historical',
    Kinesis: 'kinesis'
} as const;

export type MarketDataFeedEntityDtoTypeEnum = typeof MarketDataFeedEntityDtoTypeEnum[keyof typeof MarketDataFeedEntityDtoTypeEnum];

/**
 * 
 * @export
 * @interface MarketDataFeedOptionsDto
 */
export interface MarketDataFeedOptionsDto {
    /**
     * ID of an existing market data feed to use
     * @type {string}
     * @memberof MarketDataFeedOptionsDto
     */
    'marketDataFeedId'?: string;
    /**
     * Configuration to create a new market data feed
     * @type {object}
     * @memberof MarketDataFeedOptionsDto
     */
    'marketDataConfig'?: object;
}
/**
 * 
 * @export
 * @interface MarketPairDto
 */
export interface MarketPairDto {
    /**
     * The base token symbol
     * @type {string}
     * @memberof MarketPairDto
     */
    'base': MarketPairDtoBaseEnum;
    /**
     * The quote token symbol
     * @type {string}
     * @memberof MarketPairDto
     */
    'quote': MarketPairDtoQuoteEnum;
}

export const MarketPairDtoBaseEnum = {
    Sol: 'SOL',
    Usdc: 'USDC',
    Trump: 'TRUMP',
    Render: 'RENDER',
    Jup: 'JUP',
    Bonk: 'BONK',
    Jto: 'JTO',
    Msol: 'MSOL',
    Pyth: 'PYTH',
    Ray: 'RAY',
    Grass: 'GRASS'
} as const;

export type MarketPairDtoBaseEnum = typeof MarketPairDtoBaseEnum[keyof typeof MarketPairDtoBaseEnum];
export const MarketPairDtoQuoteEnum = {
    Sol: 'SOL',
    Usdc: 'USDC',
    Trump: 'TRUMP',
    Render: 'RENDER',
    Jup: 'JUP',
    Bonk: 'BONK',
    Jto: 'JTO',
    Msol: 'MSOL',
    Pyth: 'PYTH',
    Ray: 'RAY',
    Grass: 'GRASS'
} as const;

export type MarketPairDtoQuoteEnum = typeof MarketPairDtoQuoteEnum[keyof typeof MarketPairDtoQuoteEnum];

/**
 * 
 * @export
 * @interface MaxTradeSizeConfigDto
 */
export interface MaxTradeSizeConfigDto {
    /**
     * Maximum trade size as a decimal (e.g., 0.05 for 5%)
     * @type {number}
     * @memberof MaxTradeSizeConfigDto
     */
    'maxTradeSizePct': number;
}
/**
 * 
 * @export
 * @interface MaxTradeSizeRiskDto
 */
export interface MaxTradeSizeRiskDto {
    /**
     * 
     * @type {string}
     * @memberof MaxTradeSizeRiskDto
     */
    'type': MaxTradeSizeRiskDtoTypeEnum;
    /**
     * Configuration for MaxTradeSizeRule
     * @type {MaxTradeSizeConfigDto}
     * @memberof MaxTradeSizeRiskDto
     */
    'options': MaxTradeSizeConfigDto;
}

export const MaxTradeSizeRiskDtoTypeEnum = {
    MaxTradeSize: 'maxTradeSize'
} as const;

export type MaxTradeSizeRiskDtoTypeEnum = typeof MaxTradeSizeRiskDtoTypeEnum[keyof typeof MaxTradeSizeRiskDtoTypeEnum];

/**
 * 
 * @export
 * @interface OrderStrategyConfigDto
 */
export interface OrderStrategyConfigDto {
    /**
     * Fixed buy percentage
     * @type {number}
     * @memberof OrderStrategyConfigDto
     */
    'fixedBuyPercentage': number;
    /**
     * Sell profit threshold in percentage.
     * @type {number}
     * @memberof OrderStrategyConfigDto
     */
    'sellProfitThreshold': number;
}
/**
 * 
 * @export
 * @interface PartialCloseEventDto
 */
export interface PartialCloseEventDto {
    /**
     * Quantity that was closed in this event
     * @type {number}
     * @memberof PartialCloseEventDto
     */
    'closeSize': number;
    /**
     * Price at which the partial close was executed
     * @type {number}
     * @memberof PartialCloseEventDto
     */
    'exitPrice': number;
    /**
     * Time at which the partial close occurred
     * @type {string}
     * @memberof PartialCloseEventDto
     */
    'exitTime': string;
    /**
     * Slippage percentage realized in this close
     * @type {number}
     * @memberof PartialCloseEventDto
     */
    'slippage'?: number;
    /**
     * Network/transaction fee paid for this close
     * @type {number}
     * @memberof PartialCloseEventDto
     */
    'networkFee'?: number;
    /**
     * Partial profit and loss realized in this event
     * @type {number}
     * @memberof PartialCloseEventDto
     */
    'partialPnl'?: number;
}
/**
 * 
 * @export
 * @interface PortfolioResponseDto
 */
export interface PortfolioResponseDto {
    /**
     * Unique identifier for the portfolio
     * @type {string}
     * @memberof PortfolioResponseDto
     */
    'portfolioId': string;
    /**
     * Portfolio name
     * @type {string}
     * @memberof PortfolioResponseDto
     */
    'name': string;
    /**
     * Detailed description of the portfolio
     * @type {string}
     * @memberof PortfolioResponseDto
     */
    'description': string;
    /**
     * ID of the user who owns this portfolio
     * @type {string}
     * @memberof PortfolioResponseDto
     */
    'userId': string;
    /**
     * Set of bot IDs associated with this portfolio
     * @type {Array<string>}
     * @memberof PortfolioResponseDto
     */
    'bots': Array<string>;
    /**
     * ID of the wallet associated with this portfolio
     * @type {string}
     * @memberof PortfolioResponseDto
     */
    'walletId': string;
}
/**
 * 
 * @export
 * @interface PositionLimitConfigDto
 */
export interface PositionLimitConfigDto {
    /**
     * Maximum number of positions allowed in the wallet
     * @type {number}
     * @memberof PositionLimitConfigDto
     */
    'maxPositionCount': number;
}
/**
 * 
 * @export
 * @interface PositionLimitRiskDto
 */
export interface PositionLimitRiskDto {
    /**
     * 
     * @type {string}
     * @memberof PositionLimitRiskDto
     */
    'type': PositionLimitRiskDtoTypeEnum;
    /**
     * Configuration for PositionLimitRule
     * @type {PositionLimitConfigDto}
     * @memberof PositionLimitRiskDto
     */
    'options': PositionLimitConfigDto;
}

export const PositionLimitRiskDtoTypeEnum = {
    PositionLimit: 'positionLimit'
} as const;

export type PositionLimitRiskDtoTypeEnum = typeof PositionLimitRiskDtoTypeEnum[keyof typeof PositionLimitRiskDtoTypeEnum];

/**
 * 
 * @export
 * @interface PositionSizingConfigDto
 */
export interface PositionSizingConfigDto {
    /**
     * Maximum risk per trade as a decimal (e.g., 0.02 for 2%)
     * @type {number}
     * @memberof PositionSizingConfigDto
     */
    'perTradeRiskPct': number;
    /**
     * Stop-loss percentage as a decimal (e.g., 0.05 for 5%)
     * @type {number}
     * @memberof PositionSizingConfigDto
     */
    'stopLossPct': number;
}
/**
 * 
 * @export
 * @interface PositionSizingRiskDto
 */
export interface PositionSizingRiskDto {
    /**
     * 
     * @type {string}
     * @memberof PositionSizingRiskDto
     */
    'type': PositionSizingRiskDtoTypeEnum;
    /**
     * Configuration for PositionSizingRule
     * @type {PositionSizingConfigDto}
     * @memberof PositionSizingRiskDto
     */
    'options': PositionSizingConfigDto;
}

export const PositionSizingRiskDtoTypeEnum = {
    PositionSizing: 'positionSizing'
} as const;

export type PositionSizingRiskDtoTypeEnum = typeof PositionSizingRiskDtoTypeEnum[keyof typeof PositionSizingRiskDtoTypeEnum];

/**
 * 
 * @export
 * @interface RSIIndicatorConfigDto
 */
export interface RSIIndicatorConfigDto {
    /**
     * Indicator type identifier.
     * @type {string}
     * @memberof RSIIndicatorConfigDto
     */
    'type': RSIIndicatorConfigDtoTypeEnum;
    /**
     * 
     * @type {RSIOptionsDto}
     * @memberof RSIIndicatorConfigDto
     */
    'options': RSIOptionsDto;
}

export const RSIIndicatorConfigDtoTypeEnum = {
    Rsi: 'rsi'
} as const;

export type RSIIndicatorConfigDtoTypeEnum = typeof RSIIndicatorConfigDtoTypeEnum[keyof typeof RSIIndicatorConfigDtoTypeEnum];

/**
 * 
 * @export
 * @interface RSIOptionsDto
 */
export interface RSIOptionsDto {
    /**
     * Look-back period for RSI calculation.
     * @type {number}
     * @memberof RSIOptionsDto
     */
    'period': number;
    /**
     * Threshold above which the asset is considered overbought.
     * @type {number}
     * @memberof RSIOptionsDto
     */
    'overboughtThreshold': number;
    /**
     * Threshold below which the asset is considered oversold.
     * @type {number}
     * @memberof RSIOptionsDto
     */
    'oversoldThreshold': number;
}
/**
 * 
 * @export
 * @interface RealMarketDataFeedConfigDto
 */
export interface RealMarketDataFeedConfigDto {
    /**
     * Market pairs to track (e.g., [\"BTC/USDC\", \"SOL/USDC\"])
     * @type {Array<string>}
     * @memberof RealMarketDataFeedConfigDto
     */
    'marketPairs': Array<string>;
    /**
     * Update frequency in milliseconds
     * @type {number}
     * @memberof RealMarketDataFeedConfigDto
     */
    'updateFrequency': number;
}
/**
 * 
 * @export
 * @interface RealMarketDataFeedDto
 */
export interface RealMarketDataFeedDto {
    /**
     * Type of market data feed
     * @type {string}
     * @memberof RealMarketDataFeedDto
     */
    'type': RealMarketDataFeedDtoTypeEnum;
    /**
     * Configuration options for real market data feed
     * @type {RealMarketDataFeedConfigDto}
     * @memberof RealMarketDataFeedDto
     */
    'options': RealMarketDataFeedConfigDto;
}

export const RealMarketDataFeedDtoTypeEnum = {
    Simulation: 'simulation',
    Real: 'real',
    Historical: 'historical',
    Kinesis: 'kinesis'
} as const;

export type RealMarketDataFeedDtoTypeEnum = typeof RealMarketDataFeedDtoTypeEnum[keyof typeof RealMarketDataFeedDtoTypeEnum];

/**
 * 
 * @export
 * @interface SMAConfigDto
 */
export interface SMAConfigDto {
    /**
     * Period for calculating the short-term moving average
     * @type {number}
     * @memberof SMAConfigDto
     */
    'period': number;
}
/**
 * 
 * @export
 * @interface SMAIndicatorConfigDto
 */
export interface SMAIndicatorConfigDto {
    /**
     * 
     * @type {string}
     * @memberof SMAIndicatorConfigDto
     */
    'type': SMAIndicatorConfigDtoTypeEnum;
    /**
     * Configuration options for the moving average indicator
     * @type {SMAConfigDto}
     * @memberof SMAIndicatorConfigDto
     */
    'options': SMAConfigDto;
}

export const SMAIndicatorConfigDtoTypeEnum = {
    Sma: 'sma'
} as const;

export type SMAIndicatorConfigDtoTypeEnum = typeof SMAIndicatorConfigDtoTypeEnum[keyof typeof SMAIndicatorConfigDtoTypeEnum];

/**
 * 
 * @export
 * @interface SimulationMarketDataFeedConfigDto
 */
export interface SimulationMarketDataFeedConfigDto {
    /**
     * Market pairs to simulate (e.g., [\"BTC/USDC\", \"SOL/USDC\"])
     * @type {Array<string>}
     * @memberof SimulationMarketDataFeedConfigDto
     */
    'marketPairs': Array<string>;
    /**
     * Update frequency in milliseconds
     * @type {number}
     * @memberof SimulationMarketDataFeedConfigDto
     */
    'updateFrequency': number;
    /**
     * Volatility factor for simulated price movements (e.g., 0.01 for 1%)
     * @type {number}
     * @memberof SimulationMarketDataFeedConfigDto
     */
    'volatility': number;
}
/**
 * 
 * @export
 * @interface SimulationMarketDataFeedDto
 */
export interface SimulationMarketDataFeedDto {
    /**
     * Type of market data feed
     * @type {string}
     * @memberof SimulationMarketDataFeedDto
     */
    'type': SimulationMarketDataFeedDtoTypeEnum;
    /**
     * Configuration options for simulation market data feed
     * @type {SimulationMarketDataFeedConfigDto}
     * @memberof SimulationMarketDataFeedDto
     */
    'options': SimulationMarketDataFeedConfigDto;
}

export const SimulationMarketDataFeedDtoTypeEnum = {
    Simulation: 'simulation',
    Real: 'real',
    Historical: 'historical',
    Kinesis: 'kinesis'
} as const;

export type SimulationMarketDataFeedDtoTypeEnum = typeof SimulationMarketDataFeedDtoTypeEnum[keyof typeof SimulationMarketDataFeedDtoTypeEnum];

/**
 * 
 * @export
 * @interface SolanaWalletConfigDto
 */
export interface SolanaWalletConfigDto {
    /**
     * Type of wallet
     * @type {string}
     * @memberof SolanaWalletConfigDto
     */
    'type': SolanaWalletConfigDtoTypeEnum;
    /**
     * Configuration options for Solana wallet
     * @type {SolanaWalletOptionsDto}
     * @memberof SolanaWalletConfigDto
     */
    'options': SolanaWalletOptionsDto;
}

export const SolanaWalletConfigDtoTypeEnum = {
    SolanaWallet: 'solana-wallet'
} as const;

export type SolanaWalletConfigDtoTypeEnum = typeof SolanaWalletConfigDtoTypeEnum[keyof typeof SolanaWalletConfigDtoTypeEnum];

/**
 * 
 * @export
 * @interface SolanaWalletOptionsDto
 */
export interface SolanaWalletOptionsDto {
    /**
     * Private key in hex or base58 format
     * @type {string}
     * @memberof SolanaWalletOptionsDto
     */
    'privateKey': string;
    /**
     * Optional Solana RPC URL (defaults to mainnet)
     * @type {string}
     * @memberof SolanaWalletOptionsDto
     */
    'rpcUrl'?: string;
    /**
     * Optional sync interval in milliseconds (default: 60000 - 1 minute)
     * @type {number}
     * @memberof SolanaWalletOptionsDto
     */
    'syncIntervalMs'?: number;
}
/**
 * 
 * @export
 * @interface StochasticIndicatorConfigDto
 */
export interface StochasticIndicatorConfigDto {
    /**
     * Indicator type identifier.
     * @type {string}
     * @memberof StochasticIndicatorConfigDto
     */
    'type': StochasticIndicatorConfigDtoTypeEnum;
    /**
     * 
     * @type {StochasticOptionsDto}
     * @memberof StochasticIndicatorConfigDto
     */
    'options': StochasticOptionsDto;
}

export const StochasticIndicatorConfigDtoTypeEnum = {
    Stochastic: 'stochastic'
} as const;

export type StochasticIndicatorConfigDtoTypeEnum = typeof StochasticIndicatorConfigDtoTypeEnum[keyof typeof StochasticIndicatorConfigDtoTypeEnum];

/**
 * 
 * @export
 * @interface StochasticOptionsDto
 */
export interface StochasticOptionsDto {
    /**
     * %K period (n). Number of periods for raw %K.
     * @type {number}
     * @memberof StochasticOptionsDto
     */
    'kPeriod': number;
    /**
     * %K slowing period (m). Smoothing period for raw %K.
     * @type {number}
     * @memberof StochasticOptionsDto
     */
    'slowingPeriod': number;
    /**
     * %D period (p). Number of periods for %D line (SMA of %K).
     * @type {number}
     * @memberof StochasticOptionsDto
     */
    'dPeriod': number;
    /**
     * Overbought threshold.
     * @type {number}
     * @memberof StochasticOptionsDto
     */
    'overbought': number;
    /**
     * Oversold threshold.
     * @type {number}
     * @memberof StochasticOptionsDto
     */
    'oversold': number;
}
/**
 * 
 * @export
 * @interface StrategyConfigDto
 */
export interface StrategyConfigDto {
    /**
     * Array of indicator configurations
     * @type {Array<StrategyConfigDtoIndicatorConfigsInner>}
     * @memberof StrategyConfigDto
     */
    'indicatorConfigs': Array<StrategyConfigDtoIndicatorConfigsInner>;
    /**
     * Array of risk configurations
     * @type {Array<StrategyConfigDtoRiskConfigsInner>}
     * @memberof StrategyConfigDto
     */
    'riskConfigs': Array<StrategyConfigDtoRiskConfigsInner>;
    /**
     * Order strategy configuration
     * @type {OrderStrategyConfigDto}
     * @memberof StrategyConfigDto
     */
    'orderStrategyConfig': OrderStrategyConfigDto;
}
/**
 * @type StrategyConfigDtoIndicatorConfigsInner
 * @export
 */
export type StrategyConfigDtoIndicatorConfigsInner = ATRIndicatorConfigDto | BollingerBandsIndicatorConfigDto | DEMAIndicatorConfigDto | EMAIndicatorConfigDto | MACDIndicatorConfigDto | RSIIndicatorConfigDto | SMAIndicatorConfigDto | StochasticIndicatorConfigDto | TRIndicatorConfigDto;

/**
 * @type StrategyConfigDtoRiskConfigsInner
 * @export
 */
export type StrategyConfigDtoRiskConfigsInner = InsufficientCashRiskDto | InsufficientHoldingsRiskDto | MaxTradeSizeRiskDto | PositionLimitRiskDto | PositionSizingRiskDto;

/**
 * 
 * @export
 * @interface TRIndicatorConfigDto
 */
export interface TRIndicatorConfigDto {
    /**
     * Indicator type identifier.
     * @type {string}
     * @memberof TRIndicatorConfigDto
     */
    'type': TRIndicatorConfigDtoTypeEnum;
    /**
     * 
     * @type {object}
     * @memberof TRIndicatorConfigDto
     */
    'options': object;
}

export const TRIndicatorConfigDtoTypeEnum = {
    Tr: 'tr'
} as const;

export type TRIndicatorConfigDtoTypeEnum = typeof TRIndicatorConfigDtoTypeEnum[keyof typeof TRIndicatorConfigDtoTypeEnum];

/**
 * 
 * @export
 * @interface TradeAnalyticsDto
 */
export interface TradeAnalyticsDto {
    /**
     * Total number of trades
     * @type {number}
     * @memberof TradeAnalyticsDto
     */
    'totalTrades': number;
    /**
     * Number of profitable trades
     * @type {number}
     * @memberof TradeAnalyticsDto
     */
    'profitableTrades': number;
    /**
     * Number of unprofitable trades
     * @type {number}
     * @memberof TradeAnalyticsDto
     */
    'unprofitableTrades': number;
    /**
     * Percentage of trades that are profitable
     * @type {number}
     * @memberof TradeAnalyticsDto
     */
    'winRate': number;
    /**
     * Total profit and loss across all trades
     * @type {number}
     * @memberof TradeAnalyticsDto
     */
    'totalPnl': number;
    /**
     * Average profit per trade
     * @type {number}
     * @memberof TradeAnalyticsDto
     */
    'averagePnl': number;
    /**
     * Largest profitable trade
     * @type {number}
     * @memberof TradeAnalyticsDto
     */
    'largestProfit': number;
    /**
     * Largest losing trade
     * @type {number}
     * @memberof TradeAnalyticsDto
     */
    'largestLoss': number;
    /**
     * Maximum drawdown percentage
     * @type {number}
     * @memberof TradeAnalyticsDto
     */
    'maxDrawdown'?: number;
    /**
     * Sharpe ratio, if there is sufficient data to calculate
     * @type {number}
     * @memberof TradeAnalyticsDto
     */
    'sharpeRatio'?: number;
    /**
     * Average trade holding time in hours
     * @type {number}
     * @memberof TradeAnalyticsDto
     */
    'averageTradeHoldingTime': number;
    /**
     * Date of first trade
     * @type {string}
     * @memberof TradeAnalyticsDto
     */
    'firstTradeDate': string;
    /**
     * Date of last trade
     * @type {string}
     * @memberof TradeAnalyticsDto
     */
    'lastTradeDate': string;
    /**
     * Profit and loss metrics by market pair
     * @type {object}
     * @memberof TradeAnalyticsDto
     */
    'pnlByMarketPair': object;
}
/**
 * 
 * @export
 * @interface TradeDto
 */
export interface TradeDto {
    /**
     * Unique identifier for the trade
     * @type {string}
     * @memberof TradeDto
     */
    'tradeId'?: string;
    /**
     * The asset pair, e.g., \"BTC/USD\"
     * @type {string}
     * @memberof TradeDto
     */
    'marketPair': string;
    /**
     * The total size (quantity) of the trade
     * @type {number}
     * @memberof TradeDto
     */
    'size': number;
    /**
     * The quantity remaining open in the trade
     * @type {number}
     * @memberof TradeDto
     */
    'openSize': number;
    /**
     * The entry price at which the trade was executed
     * @type {number}
     * @memberof TradeDto
     */
    'entryPrice': number;
    /**
     * The time the trade was executed (entry time)
     * @type {string}
     * @memberof TradeDto
     */
    'entryTime': string;
    /**
     * Slippage percentage realized when entering the trade
     * @type {number}
     * @memberof TradeDto
     */
    'entrySlippage'?: number;
    /**
     * Network/transaction fee paid when entering the trade
     * @type {number}
     * @memberof TradeDto
     */
    'entryNetworkFee'?: number;
    /**
     * The time the trade was closed (if fully closed)
     * @type {string}
     * @memberof TradeDto
     */
    'exitTime'?: string;
    /**
     * The price at which the trade was closed (if fully closed)
     * @type {number}
     * @memberof TradeDto
     */
    'exitPrice'?: number;
    /**
     * Final profit and loss if the trade is fully closed
     * @type {number}
     * @memberof TradeDto
     */
    'pnl'?: number;
    /**
     * An array of partial close events applied to this trade
     * @type {Array<PartialCloseEventDto>}
     * @memberof TradeDto
     */
    'partialCloses': Array<PartialCloseEventDto>;
    /**
     * The current state of the trade (OPEN or CLOSED)
     * @type {string}
     * @memberof TradeDto
     */
    'state': TradeDtoStateEnum;
}

export const TradeDtoStateEnum = {
    Open: 'OPEN',
    Closed: 'CLOSED'
} as const;

export type TradeDtoStateEnum = typeof TradeDtoStateEnum[keyof typeof TradeDtoStateEnum];

/**
 * 
 * @export
 * @interface TradesDataDto
 */
export interface TradesDataDto {
    /**
     * An array of executed trades
     * @type {Array<TradeDto>}
     * @memberof TradesDataDto
     */
    'trades': Array<TradeDto>;
    /**
     * The total number of trades recorded
     * @type {number}
     * @memberof TradesDataDto
     */
    'totalTrades': number;
}
/**
 * 
 * @export
 * @interface UpdateBotDto
 */
export interface UpdateBotDto {
    /**
     * Strategy configuration containing indicator and risk configurations
     * @type {StrategyConfigDto}
     * @memberof UpdateBotDto
     */
    'strategyConfig'?: StrategyConfigDto;
    /**
     * Name of the bot/strategy
     * @type {string}
     * @memberof UpdateBotDto
     */
    'name'?: string;
    /**
     * Description of the bot/strategy
     * @type {string}
     * @memberof UpdateBotDto
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface UpdateMarketDataFeedDto
 */
export interface UpdateMarketDataFeedDto {
    /**
     * Type of market data feed
     * @type {string}
     * @memberof UpdateMarketDataFeedDto
     */
    'type'?: UpdateMarketDataFeedDtoTypeEnum;
    /**
     * 
     * @type {CreateMarketDataFeedDtoOptions}
     * @memberof UpdateMarketDataFeedDto
     */
    'options'?: CreateMarketDataFeedDtoOptions;
}

export const UpdateMarketDataFeedDtoTypeEnum = {
    Simulation: 'simulation',
    Real: 'real',
    Historical: 'historical',
    Kinesis: 'kinesis'
} as const;

export type UpdateMarketDataFeedDtoTypeEnum = typeof UpdateMarketDataFeedDtoTypeEnum[keyof typeof UpdateMarketDataFeedDtoTypeEnum];

/**
 * 
 * @export
 * @interface UpdatePortfolioDto
 */
export interface UpdatePortfolioDto {
    /**
     * Portfolio name
     * @type {string}
     * @memberof UpdatePortfolioDto
     */
    'name'?: string;
    /**
     * Detailed description of the portfolio
     * @type {string}
     * @memberof UpdatePortfolioDto
     */
    'description'?: string;
    /**
     * ID of the wallet associated with this portfolio
     * @type {string}
     * @memberof UpdatePortfolioDto
     */
    'walletId'?: string;
    /**
     * Set of bot IDs to associate with the portfolio
     * @type {Array<string>}
     * @memberof UpdatePortfolioDto
     */
    'bots'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UpdateUserDto
 */
export interface UpdateUserDto {
    /**
     * The user\'s wallet public key
     * @type {string}
     * @memberof UpdateUserDto
     */
    'walletPublicKey'?: string;
    /**
     * Portfolio ID to associate with this user
     * @type {string}
     * @memberof UpdateUserDto
     */
    'portfolioId'?: string;
}
/**
 * 
 * @export
 * @interface UpdateWalletDto
 */
export interface UpdateWalletDto {
    /**
     * Name of the wallet (for identification)
     * @type {string}
     * @memberof UpdateWalletDto
     */
    'name'?: string;
    /**
     * Optional description for the wallet
     * @type {string}
     * @memberof UpdateWalletDto
     */
    'description'?: string;
    /**
     * 
     * @type {CreateWalletDtoOptions}
     * @memberof UpdateWalletDto
     */
    'options'?: CreateWalletDtoOptions;
    /**
     * Snapshot configuration for the wallet
     * @type {WalletSnapshotConfigDto}
     * @memberof UpdateWalletDto
     */
    'snapshotConfig'?: WalletSnapshotConfigDto;
}
/**
 * 
 * @export
 * @interface UserResponseDto
 */
export interface UserResponseDto {
    /**
     * Unique identifier for the user
     * @type {string}
     * @memberof UserResponseDto
     */
    'id': string;
    /**
     * The user\'s wallet public key
     * @type {string}
     * @memberof UserResponseDto
     */
    'walletPublicKey': string;
    /**
     * ID of the portfolio associated with this user
     * @type {string}
     * @memberof UserResponseDto
     */
    'portfolioId': string;
}
/**
 * 
 * @export
 * @interface WalletEntityDto
 */
export interface WalletEntityDto {
    /**
     * Unique identifier for the wallet
     * @type {string}
     * @memberof WalletEntityDto
     */
    'id': string;
    /**
     * Name of the wallet
     * @type {string}
     * @memberof WalletEntityDto
     */
    'name': string;
    /**
     * Description of the wallet
     * @type {string}
     * @memberof WalletEntityDto
     */
    'description'?: string;
    /**
     * Type of wallet (in-memory, solana-wallet, etc.)
     * @type {string}
     * @memberof WalletEntityDto
     */
    'type': WalletEntityDtoTypeEnum;
    /**
     * Configuration settings for the wallet
     * @type {{ [key: string]: any; }}
     * @memberof WalletEntityDto
     */
    'config': { [key: string]: any; };
    /**
     * Snapshot configuration
     * @type {WalletSnapshotConfigDto}
     * @memberof WalletEntityDto
     */
    'snapshotConfig'?: WalletSnapshotConfigDto;
    /**
     * Creation date of the wallet
     * @type {string}
     * @memberof WalletEntityDto
     */
    'createdAt': string;
    /**
     * Last update date of the wallet
     * @type {string}
     * @memberof WalletEntityDto
     */
    'updatedAt': string;
}

export const WalletEntityDtoTypeEnum = {
    InMemory: 'in-memory',
    SolanaWallet: 'solana-wallet'
} as const;

export type WalletEntityDtoTypeEnum = typeof WalletEntityDtoTypeEnum[keyof typeof WalletEntityDtoTypeEnum];

/**
 * 
 * @export
 * @interface WalletSnapshotConfigDto
 */
export interface WalletSnapshotConfigDto {
    /**
     * Whether snapshots are enabled for this wallet
     * @type {boolean}
     * @memberof WalletSnapshotConfigDto
     */
    'enabled': boolean;
    /**
     * Interval in minutes between snapshots
     * @type {number}
     * @memberof WalletSnapshotConfigDto
     */
    'intervalMinutes': number;
    /**
     * Number of days to retain snapshots (0 for indefinite)
     * @type {number}
     * @memberof WalletSnapshotConfigDto
     */
    'retentionDays': number;
}
/**
 * 
 * @export
 * @interface WalletSnapshotResponseDto
 */
export interface WalletSnapshotResponseDto {
    /**
     * Wallet ID
     * @type {string}
     * @memberof WalletSnapshotResponseDto
     */
    'walletId': string;
    /**
     * Timestamp of the snapshot
     * @type {string}
     * @memberof WalletSnapshotResponseDto
     */
    'timestamp': string;
    /**
     * Total wallet value at this time
     * @type {number}
     * @memberof WalletSnapshotResponseDto
     */
    'walletValue': number;
    /**
     * Cash balance at this time
     * @type {number}
     * @memberof WalletSnapshotResponseDto
     */
    'cashBalance': number;
    /**
     * Value of positions at this time
     * @type {number}
     * @memberof WalletSnapshotResponseDto
     */
    'positionsValue': number;
    /**
     * Profit and loss at this time
     * @type {number}
     * @memberof WalletSnapshotResponseDto
     */
    'pnl'?: number;
}

/**
 * AnalyticsApi - axios parameter creator
 * @export
 */
export const AnalyticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Generate performance reports
         * @param {string} format 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyticsControllerGenerateReports: async (format: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'format' is not null or undefined
            assertParamExists('analyticsControllerGenerateReports', 'format', format)
            const localVarPath = `/analytics/reports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an overview of trading performance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyticsControllerGetAnalyticsOverview: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/analytics/overview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get detailed analytics for a specific bot
         * @param {string} botId 
         * @param {string} startDate 
         * @param {string} endDate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyticsControllerGetBotAnalytics: async (botId: string, startDate: string, endDate: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('analyticsControllerGetBotAnalytics', 'botId', botId)
            // verify required parameter 'startDate' is not null or undefined
            assertParamExists('analyticsControllerGetBotAnalytics', 'startDate', startDate)
            // verify required parameter 'endDate' is not null or undefined
            assertParamExists('analyticsControllerGetBotAnalytics', 'endDate', endDate)
            const localVarPath = `/analytics/bots/{botId}`
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get market analytics data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyticsControllerGetMarketAnalytics: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/analytics/market`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnalyticsApi - functional programming interface
 * @export
 */
export const AnalyticsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnalyticsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Generate performance reports
         * @param {string} format 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analyticsControllerGenerateReports(format: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analyticsControllerGenerateReports(format, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.analyticsControllerGenerateReports']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get an overview of trading performance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analyticsControllerGetAnalyticsOverview(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analyticsControllerGetAnalyticsOverview(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.analyticsControllerGetAnalyticsOverview']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get detailed analytics for a specific bot
         * @param {string} botId 
         * @param {string} startDate 
         * @param {string} endDate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analyticsControllerGetBotAnalytics(botId: string, startDate: string, endDate: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analyticsControllerGetBotAnalytics(botId, startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.analyticsControllerGetBotAnalytics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get market analytics data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analyticsControllerGetMarketAnalytics(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analyticsControllerGetMarketAnalytics(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.analyticsControllerGetMarketAnalytics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AnalyticsApi - factory interface
 * @export
 */
export const AnalyticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnalyticsApiFp(configuration)
    return {
        /**
         * 
         * @summary Generate performance reports
         * @param {string} format 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyticsControllerGenerateReports(format: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.analyticsControllerGenerateReports(format, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get an overview of trading performance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyticsControllerGetAnalyticsOverview(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.analyticsControllerGetAnalyticsOverview(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get detailed analytics for a specific bot
         * @param {string} botId 
         * @param {string} startDate 
         * @param {string} endDate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyticsControllerGetBotAnalytics(botId: string, startDate: string, endDate: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.analyticsControllerGetBotAnalytics(botId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get market analytics data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyticsControllerGetMarketAnalytics(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.analyticsControllerGetMarketAnalytics(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnalyticsApi - object-oriented interface
 * @export
 * @class AnalyticsApi
 * @extends {BaseAPI}
 */
export class AnalyticsApi extends BaseAPI {
    /**
     * 
     * @summary Generate performance reports
     * @param {string} format 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public analyticsControllerGenerateReports(format: string, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).analyticsControllerGenerateReports(format, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get an overview of trading performance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public analyticsControllerGetAnalyticsOverview(options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).analyticsControllerGetAnalyticsOverview(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get detailed analytics for a specific bot
     * @param {string} botId 
     * @param {string} startDate 
     * @param {string} endDate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public analyticsControllerGetBotAnalytics(botId: string, startDate: string, endDate: string, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).analyticsControllerGetBotAnalytics(botId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get market analytics data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public analyticsControllerGetMarketAnalytics(options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).analyticsControllerGetMarketAnalytics(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BotsApi - axios parameter creator
 * @export
 */
export const BotsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create and start a new bot
         * @param {CreateBotDto} createBotDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsControllerCreateBot: async (createBotDto: CreateBotDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createBotDto' is not null or undefined
            assertParamExists('botsControllerCreateBot', 'createBotDto', createBotDto)
            const localVarPath = `/bots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createBotDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a trading bot
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsControllerDeleteBot: async (botId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('botsControllerDeleteBot', 'botId', botId)
            const localVarPath = `/bots/{botId}`
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all trading bots
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsControllerGetAllBots: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve details for a specific bot
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsControllerGetBot: async (botId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('botsControllerGetBot', 'botId', botId)
            const localVarPath = `/bots/{botId}`
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the strategy configuration for the specified bot
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsControllerGetStrategyConfig: async (botId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('botsControllerGetStrategyConfig', 'botId', botId)
            const localVarPath = `/bots/{botId}/strategy-config`
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve trade performance analytics for the specified bot
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsControllerGetTradePerformance: async (botId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('botsControllerGetTradePerformance', 'botId', botId)
            const localVarPath = `/bots/{botId}/trades/performance`
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve trades for a specific bot
         * @param {string} botId 
         * @param {BotsControllerGetTradesStateEnum} [state] Filter trades by state (OPEN or CLOSED)
         * @param {string} [marketPair] Filter trades by market pair (format: BTC/USDC)
         * @param {string} [fromDate] Filter trades by entry date (ISO date string)
         * @param {string} [toDate] Filter trades by entry date (ISO date string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsControllerGetTrades: async (botId: string, state?: BotsControllerGetTradesStateEnum, marketPair?: string, fromDate?: string, toDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('botsControllerGetTrades', 'botId', botId)
            const localVarPath = `/bots/{botId}/trades`
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (marketPair !== undefined) {
                localVarQueryParameter['marketPair'] = marketPair;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = toDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Pause a bot instance without closing positions
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsControllerPauseBot: async (botId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('botsControllerPauseBot', 'botId', botId)
            const localVarPath = `/bots/{botId}/pause`
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Resume a paused bot instance
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsControllerResumeBot: async (botId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('botsControllerResumeBot', 'botId', botId)
            const localVarPath = `/bots/{botId}/resume`
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start the bot instance with the given ID
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsControllerStartBot: async (botId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('botsControllerStartBot', 'botId', botId)
            const localVarPath = `/bots/{botId}/start`
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop the trading bot and close all open positions
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsControllerStopBot: async (botId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('botsControllerStopBot', 'botId', botId)
            const localVarPath = `/bots/{botId}/stop`
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a bot\'s configuration
         * @param {string} botId 
         * @param {UpdateBotDto} updateBotDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsControllerUpdateBot: async (botId: string, updateBotDto: UpdateBotDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('botsControllerUpdateBot', 'botId', botId)
            // verify required parameter 'updateBotDto' is not null or undefined
            assertParamExists('botsControllerUpdateBot', 'updateBotDto', updateBotDto)
            const localVarPath = `/bots/{botId}`
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateBotDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the strategy configuration for a specific bot
         * @param {string} botId 
         * @param {StrategyConfigDto} strategyConfigDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsControllerUpdateStrategyConfig: async (botId: string, strategyConfigDto: StrategyConfigDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('botsControllerUpdateStrategyConfig', 'botId', botId)
            // verify required parameter 'strategyConfigDto' is not null or undefined
            assertParamExists('botsControllerUpdateStrategyConfig', 'strategyConfigDto', strategyConfigDto)
            const localVarPath = `/bots/{botId}/strategy-config`
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(strategyConfigDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BotsApi - functional programming interface
 * @export
 */
export const BotsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BotsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create and start a new bot
         * @param {CreateBotDto} createBotDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botsControllerCreateBot(createBotDto: CreateBotDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotEntityDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botsControllerCreateBot(createBotDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BotsApi.botsControllerCreateBot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a trading bot
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botsControllerDeleteBot(botId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botsControllerDeleteBot(botId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BotsApi.botsControllerDeleteBot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all trading bots
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botsControllerGetAllBots(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BotEntityDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botsControllerGetAllBots(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BotsApi.botsControllerGetAllBots']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve details for a specific bot
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botsControllerGetBot(botId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotEntityDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botsControllerGetBot(botId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BotsApi.botsControllerGetBot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve the strategy configuration for the specified bot
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botsControllerGetStrategyConfig(botId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StrategyConfigDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botsControllerGetStrategyConfig(botId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BotsApi.botsControllerGetStrategyConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve trade performance analytics for the specified bot
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botsControllerGetTradePerformance(botId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TradeAnalyticsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botsControllerGetTradePerformance(botId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BotsApi.botsControllerGetTradePerformance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve trades for a specific bot
         * @param {string} botId 
         * @param {BotsControllerGetTradesStateEnum} [state] Filter trades by state (OPEN or CLOSED)
         * @param {string} [marketPair] Filter trades by market pair (format: BTC/USDC)
         * @param {string} [fromDate] Filter trades by entry date (ISO date string)
         * @param {string} [toDate] Filter trades by entry date (ISO date string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botsControllerGetTrades(botId: string, state?: BotsControllerGetTradesStateEnum, marketPair?: string, fromDate?: string, toDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TradesDataDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botsControllerGetTrades(botId, state, marketPair, fromDate, toDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BotsApi.botsControllerGetTrades']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Pause a bot instance without closing positions
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botsControllerPauseBot(botId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotEntityDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botsControllerPauseBot(botId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BotsApi.botsControllerPauseBot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Resume a paused bot instance
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botsControllerResumeBot(botId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotEntityDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botsControllerResumeBot(botId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BotsApi.botsControllerResumeBot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Start the bot instance with the given ID
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botsControllerStartBot(botId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotEntityDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botsControllerStartBot(botId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BotsApi.botsControllerStartBot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Stop the trading bot and close all open positions
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botsControllerStopBot(botId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotEntityDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botsControllerStopBot(botId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BotsApi.botsControllerStopBot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a bot\'s configuration
         * @param {string} botId 
         * @param {UpdateBotDto} updateBotDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botsControllerUpdateBot(botId: string, updateBotDto: UpdateBotDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotEntityDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botsControllerUpdateBot(botId, updateBotDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BotsApi.botsControllerUpdateBot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the strategy configuration for a specific bot
         * @param {string} botId 
         * @param {StrategyConfigDto} strategyConfigDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botsControllerUpdateStrategyConfig(botId: string, strategyConfigDto: StrategyConfigDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotEntityDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botsControllerUpdateStrategyConfig(botId, strategyConfigDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BotsApi.botsControllerUpdateStrategyConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BotsApi - factory interface
 * @export
 */
export const BotsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BotsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create and start a new bot
         * @param {CreateBotDto} createBotDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsControllerCreateBot(createBotDto: CreateBotDto, options?: RawAxiosRequestConfig): AxiosPromise<BotEntityDto> {
            return localVarFp.botsControllerCreateBot(createBotDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a trading bot
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsControllerDeleteBot(botId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.botsControllerDeleteBot(botId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all trading bots
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsControllerGetAllBots(options?: RawAxiosRequestConfig): AxiosPromise<Array<BotEntityDto>> {
            return localVarFp.botsControllerGetAllBots(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve details for a specific bot
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsControllerGetBot(botId: string, options?: RawAxiosRequestConfig): AxiosPromise<BotEntityDto> {
            return localVarFp.botsControllerGetBot(botId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the strategy configuration for the specified bot
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsControllerGetStrategyConfig(botId: string, options?: RawAxiosRequestConfig): AxiosPromise<StrategyConfigDto> {
            return localVarFp.botsControllerGetStrategyConfig(botId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve trade performance analytics for the specified bot
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsControllerGetTradePerformance(botId: string, options?: RawAxiosRequestConfig): AxiosPromise<TradeAnalyticsDto> {
            return localVarFp.botsControllerGetTradePerformance(botId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve trades for a specific bot
         * @param {string} botId 
         * @param {BotsControllerGetTradesStateEnum} [state] Filter trades by state (OPEN or CLOSED)
         * @param {string} [marketPair] Filter trades by market pair (format: BTC/USDC)
         * @param {string} [fromDate] Filter trades by entry date (ISO date string)
         * @param {string} [toDate] Filter trades by entry date (ISO date string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsControllerGetTrades(botId: string, state?: BotsControllerGetTradesStateEnum, marketPair?: string, fromDate?: string, toDate?: string, options?: RawAxiosRequestConfig): AxiosPromise<TradesDataDto> {
            return localVarFp.botsControllerGetTrades(botId, state, marketPair, fromDate, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Pause a bot instance without closing positions
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsControllerPauseBot(botId: string, options?: RawAxiosRequestConfig): AxiosPromise<BotEntityDto> {
            return localVarFp.botsControllerPauseBot(botId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Resume a paused bot instance
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsControllerResumeBot(botId: string, options?: RawAxiosRequestConfig): AxiosPromise<BotEntityDto> {
            return localVarFp.botsControllerResumeBot(botId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Start the bot instance with the given ID
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsControllerStartBot(botId: string, options?: RawAxiosRequestConfig): AxiosPromise<BotEntityDto> {
            return localVarFp.botsControllerStartBot(botId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stop the trading bot and close all open positions
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsControllerStopBot(botId: string, options?: RawAxiosRequestConfig): AxiosPromise<BotEntityDto> {
            return localVarFp.botsControllerStopBot(botId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a bot\'s configuration
         * @param {string} botId 
         * @param {UpdateBotDto} updateBotDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsControllerUpdateBot(botId: string, updateBotDto: UpdateBotDto, options?: RawAxiosRequestConfig): AxiosPromise<BotEntityDto> {
            return localVarFp.botsControllerUpdateBot(botId, updateBotDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the strategy configuration for a specific bot
         * @param {string} botId 
         * @param {StrategyConfigDto} strategyConfigDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsControllerUpdateStrategyConfig(botId: string, strategyConfigDto: StrategyConfigDto, options?: RawAxiosRequestConfig): AxiosPromise<BotEntityDto> {
            return localVarFp.botsControllerUpdateStrategyConfig(botId, strategyConfigDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BotsApi - object-oriented interface
 * @export
 * @class BotsApi
 * @extends {BaseAPI}
 */
export class BotsApi extends BaseAPI {
    /**
     * 
     * @summary Create and start a new bot
     * @param {CreateBotDto} createBotDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public botsControllerCreateBot(createBotDto: CreateBotDto, options?: RawAxiosRequestConfig) {
        return BotsApiFp(this.configuration).botsControllerCreateBot(createBotDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a trading bot
     * @param {string} botId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public botsControllerDeleteBot(botId: string, options?: RawAxiosRequestConfig) {
        return BotsApiFp(this.configuration).botsControllerDeleteBot(botId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all trading bots
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public botsControllerGetAllBots(options?: RawAxiosRequestConfig) {
        return BotsApiFp(this.configuration).botsControllerGetAllBots(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve details for a specific bot
     * @param {string} botId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public botsControllerGetBot(botId: string, options?: RawAxiosRequestConfig) {
        return BotsApiFp(this.configuration).botsControllerGetBot(botId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the strategy configuration for the specified bot
     * @param {string} botId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public botsControllerGetStrategyConfig(botId: string, options?: RawAxiosRequestConfig) {
        return BotsApiFp(this.configuration).botsControllerGetStrategyConfig(botId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve trade performance analytics for the specified bot
     * @param {string} botId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public botsControllerGetTradePerformance(botId: string, options?: RawAxiosRequestConfig) {
        return BotsApiFp(this.configuration).botsControllerGetTradePerformance(botId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve trades for a specific bot
     * @param {string} botId 
     * @param {BotsControllerGetTradesStateEnum} [state] Filter trades by state (OPEN or CLOSED)
     * @param {string} [marketPair] Filter trades by market pair (format: BTC/USDC)
     * @param {string} [fromDate] Filter trades by entry date (ISO date string)
     * @param {string} [toDate] Filter trades by entry date (ISO date string)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public botsControllerGetTrades(botId: string, state?: BotsControllerGetTradesStateEnum, marketPair?: string, fromDate?: string, toDate?: string, options?: RawAxiosRequestConfig) {
        return BotsApiFp(this.configuration).botsControllerGetTrades(botId, state, marketPair, fromDate, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Pause a bot instance without closing positions
     * @param {string} botId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public botsControllerPauseBot(botId: string, options?: RawAxiosRequestConfig) {
        return BotsApiFp(this.configuration).botsControllerPauseBot(botId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Resume a paused bot instance
     * @param {string} botId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public botsControllerResumeBot(botId: string, options?: RawAxiosRequestConfig) {
        return BotsApiFp(this.configuration).botsControllerResumeBot(botId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Start the bot instance with the given ID
     * @param {string} botId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public botsControllerStartBot(botId: string, options?: RawAxiosRequestConfig) {
        return BotsApiFp(this.configuration).botsControllerStartBot(botId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stop the trading bot and close all open positions
     * @param {string} botId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public botsControllerStopBot(botId: string, options?: RawAxiosRequestConfig) {
        return BotsApiFp(this.configuration).botsControllerStopBot(botId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a bot\'s configuration
     * @param {string} botId 
     * @param {UpdateBotDto} updateBotDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public botsControllerUpdateBot(botId: string, updateBotDto: UpdateBotDto, options?: RawAxiosRequestConfig) {
        return BotsApiFp(this.configuration).botsControllerUpdateBot(botId, updateBotDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the strategy configuration for a specific bot
     * @param {string} botId 
     * @param {StrategyConfigDto} strategyConfigDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public botsControllerUpdateStrategyConfig(botId: string, strategyConfigDto: StrategyConfigDto, options?: RawAxiosRequestConfig) {
        return BotsApiFp(this.configuration).botsControllerUpdateStrategyConfig(botId, strategyConfigDto, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const BotsControllerGetTradesStateEnum = {
    Open: 'OPEN',
    Closed: 'CLOSED'
} as const;
export type BotsControllerGetTradesStateEnum = typeof BotsControllerGetTradesStateEnum[keyof typeof BotsControllerGetTradesStateEnum];


/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Check application health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthControllerCheck: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Check application health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthControllerCheck(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthControllerCheck(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.healthControllerCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * 
         * @summary Check application health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthControllerCheck(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.healthControllerCheck(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
    /**
     * 
     * @summary Check application health
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public healthControllerCheck(options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).healthControllerCheck(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HomeApi - axios parameter creator
 * @export
 */
export const HomeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Home endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        homeControllerHome: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HomeApi - functional programming interface
 * @export
 */
export const HomeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HomeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Home endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async homeControllerHome(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.homeControllerHome(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HomeApi.homeControllerHome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HomeApi - factory interface
 * @export
 */
export const HomeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HomeApiFp(configuration)
    return {
        /**
         * 
         * @summary Home endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        homeControllerHome(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.homeControllerHome(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HomeApi - object-oriented interface
 * @export
 * @class HomeApi
 * @extends {BaseAPI}
 */
export class HomeApi extends BaseAPI {
    /**
     * 
     * @summary Home endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HomeApi
     */
    public homeControllerHome(options?: RawAxiosRequestConfig) {
        return HomeApiFp(this.configuration).homeControllerHome(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MarketDataFeedsApi - axios parameter creator
 * @export
 */
export const MarketDataFeedsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new market data feed
         * @param {CreateMarketDataFeedDto} createMarketDataFeedDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketDataFeedControllerCreate: async (createMarketDataFeedDto: CreateMarketDataFeedDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createMarketDataFeedDto' is not null or undefined
            assertParamExists('marketDataFeedControllerCreate', 'createMarketDataFeedDto', createMarketDataFeedDto)
            const localVarPath = `/market-data-feeds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createMarketDataFeedDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all market data feeds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketDataFeedControllerFindAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/market-data-feeds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific market data feed
         * @param {string} id Market data feed ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketDataFeedControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('marketDataFeedControllerFindOne', 'id', id)
            const localVarPath = `/market-data-feeds/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the default market data feed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketDataFeedControllerGetDefault: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/market-data-feeds/default`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a snapshot for a specific market data feed
         * @param {string} id Market data feed ID
         * @param {MarketDataFeedControllerGetMarketDataFeedSnapshotPeriodEnum} [period] Time period for the snapshot
         * @param {string} [marketPairs] Comma-separated list of market pairs to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketDataFeedControllerGetMarketDataFeedSnapshot: async (id: string, period?: MarketDataFeedControllerGetMarketDataFeedSnapshotPeriodEnum, marketPairs?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('marketDataFeedControllerGetMarketDataFeedSnapshot', 'id', id)
            const localVarPath = `/market-data-feeds/{id}/snapshots`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (marketPairs !== undefined) {
                localVarQueryParameter['marketPairs'] = marketPairs;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a snapshot of market data for the default real price data
         * @param {MarketDataFeedControllerGetSnapshotPeriodEnum} [period] Time period for the snapshot
         * @param {string} [marketPairs] Comma-separated list of market pairs to filter by (e.g., SOL/USDC,BTC/USDC)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketDataFeedControllerGetSnapshot: async (period?: MarketDataFeedControllerGetSnapshotPeriodEnum, marketPairs?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/market-data-feeds/snapshots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (marketPairs !== undefined) {
                localVarQueryParameter['marketPairs'] = marketPairs;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a market data feed
         * @param {string} id Market data feed ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketDataFeedControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('marketDataFeedControllerRemove', 'id', id)
            const localVarPath = `/market-data-feeds/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a market data feed
         * @param {string} id Market data feed ID
         * @param {UpdateMarketDataFeedDto} updateMarketDataFeedDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketDataFeedControllerUpdate: async (id: string, updateMarketDataFeedDto: UpdateMarketDataFeedDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('marketDataFeedControllerUpdate', 'id', id)
            // verify required parameter 'updateMarketDataFeedDto' is not null or undefined
            assertParamExists('marketDataFeedControllerUpdate', 'updateMarketDataFeedDto', updateMarketDataFeedDto)
            const localVarPath = `/market-data-feeds/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMarketDataFeedDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MarketDataFeedsApi - functional programming interface
 * @export
 */
export const MarketDataFeedsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MarketDataFeedsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new market data feed
         * @param {CreateMarketDataFeedDto} createMarketDataFeedDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async marketDataFeedControllerCreate(createMarketDataFeedDto: CreateMarketDataFeedDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MarketDataFeedEntityDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.marketDataFeedControllerCreate(createMarketDataFeedDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataFeedsApi.marketDataFeedControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all market data feeds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async marketDataFeedControllerFindAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MarketDataFeedEntityDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.marketDataFeedControllerFindAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataFeedsApi.marketDataFeedControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a specific market data feed
         * @param {string} id Market data feed ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async marketDataFeedControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MarketDataFeedEntityDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.marketDataFeedControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataFeedsApi.marketDataFeedControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the default market data feed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async marketDataFeedControllerGetDefault(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MarketDataFeedEntityDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.marketDataFeedControllerGetDefault(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataFeedsApi.marketDataFeedControllerGetDefault']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a snapshot for a specific market data feed
         * @param {string} id Market data feed ID
         * @param {MarketDataFeedControllerGetMarketDataFeedSnapshotPeriodEnum} [period] Time period for the snapshot
         * @param {string} [marketPairs] Comma-separated list of market pairs to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async marketDataFeedControllerGetMarketDataFeedSnapshot(id: string, period?: MarketDataFeedControllerGetMarketDataFeedSnapshotPeriodEnum, marketPairs?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MarketDataDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.marketDataFeedControllerGetMarketDataFeedSnapshot(id, period, marketPairs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataFeedsApi.marketDataFeedControllerGetMarketDataFeedSnapshot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a snapshot of market data for the default real price data
         * @param {MarketDataFeedControllerGetSnapshotPeriodEnum} [period] Time period for the snapshot
         * @param {string} [marketPairs] Comma-separated list of market pairs to filter by (e.g., SOL/USDC,BTC/USDC)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async marketDataFeedControllerGetSnapshot(period?: MarketDataFeedControllerGetSnapshotPeriodEnum, marketPairs?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MarketDataDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.marketDataFeedControllerGetSnapshot(period, marketPairs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataFeedsApi.marketDataFeedControllerGetSnapshot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a market data feed
         * @param {string} id Market data feed ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async marketDataFeedControllerRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.marketDataFeedControllerRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataFeedsApi.marketDataFeedControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a market data feed
         * @param {string} id Market data feed ID
         * @param {UpdateMarketDataFeedDto} updateMarketDataFeedDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async marketDataFeedControllerUpdate(id: string, updateMarketDataFeedDto: UpdateMarketDataFeedDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MarketDataFeedEntityDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.marketDataFeedControllerUpdate(id, updateMarketDataFeedDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketDataFeedsApi.marketDataFeedControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MarketDataFeedsApi - factory interface
 * @export
 */
export const MarketDataFeedsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MarketDataFeedsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new market data feed
         * @param {CreateMarketDataFeedDto} createMarketDataFeedDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketDataFeedControllerCreate(createMarketDataFeedDto: CreateMarketDataFeedDto, options?: RawAxiosRequestConfig): AxiosPromise<MarketDataFeedEntityDto> {
            return localVarFp.marketDataFeedControllerCreate(createMarketDataFeedDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all market data feeds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketDataFeedControllerFindAll(options?: RawAxiosRequestConfig): AxiosPromise<Array<MarketDataFeedEntityDto>> {
            return localVarFp.marketDataFeedControllerFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific market data feed
         * @param {string} id Market data feed ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketDataFeedControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<MarketDataFeedEntityDto> {
            return localVarFp.marketDataFeedControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the default market data feed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketDataFeedControllerGetDefault(options?: RawAxiosRequestConfig): AxiosPromise<MarketDataFeedEntityDto> {
            return localVarFp.marketDataFeedControllerGetDefault(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a snapshot for a specific market data feed
         * @param {string} id Market data feed ID
         * @param {MarketDataFeedControllerGetMarketDataFeedSnapshotPeriodEnum} [period] Time period for the snapshot
         * @param {string} [marketPairs] Comma-separated list of market pairs to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketDataFeedControllerGetMarketDataFeedSnapshot(id: string, period?: MarketDataFeedControllerGetMarketDataFeedSnapshotPeriodEnum, marketPairs?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<MarketDataDto>> {
            return localVarFp.marketDataFeedControllerGetMarketDataFeedSnapshot(id, period, marketPairs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a snapshot of market data for the default real price data
         * @param {MarketDataFeedControllerGetSnapshotPeriodEnum} [period] Time period for the snapshot
         * @param {string} [marketPairs] Comma-separated list of market pairs to filter by (e.g., SOL/USDC,BTC/USDC)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketDataFeedControllerGetSnapshot(period?: MarketDataFeedControllerGetSnapshotPeriodEnum, marketPairs?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<MarketDataDto>> {
            return localVarFp.marketDataFeedControllerGetSnapshot(period, marketPairs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a market data feed
         * @param {string} id Market data feed ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketDataFeedControllerRemove(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.marketDataFeedControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a market data feed
         * @param {string} id Market data feed ID
         * @param {UpdateMarketDataFeedDto} updateMarketDataFeedDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketDataFeedControllerUpdate(id: string, updateMarketDataFeedDto: UpdateMarketDataFeedDto, options?: RawAxiosRequestConfig): AxiosPromise<MarketDataFeedEntityDto> {
            return localVarFp.marketDataFeedControllerUpdate(id, updateMarketDataFeedDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MarketDataFeedsApi - object-oriented interface
 * @export
 * @class MarketDataFeedsApi
 * @extends {BaseAPI}
 */
export class MarketDataFeedsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new market data feed
     * @param {CreateMarketDataFeedDto} createMarketDataFeedDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataFeedsApi
     */
    public marketDataFeedControllerCreate(createMarketDataFeedDto: CreateMarketDataFeedDto, options?: RawAxiosRequestConfig) {
        return MarketDataFeedsApiFp(this.configuration).marketDataFeedControllerCreate(createMarketDataFeedDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all market data feeds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataFeedsApi
     */
    public marketDataFeedControllerFindAll(options?: RawAxiosRequestConfig) {
        return MarketDataFeedsApiFp(this.configuration).marketDataFeedControllerFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific market data feed
     * @param {string} id Market data feed ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataFeedsApi
     */
    public marketDataFeedControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return MarketDataFeedsApiFp(this.configuration).marketDataFeedControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the default market data feed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataFeedsApi
     */
    public marketDataFeedControllerGetDefault(options?: RawAxiosRequestConfig) {
        return MarketDataFeedsApiFp(this.configuration).marketDataFeedControllerGetDefault(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a snapshot for a specific market data feed
     * @param {string} id Market data feed ID
     * @param {MarketDataFeedControllerGetMarketDataFeedSnapshotPeriodEnum} [period] Time period for the snapshot
     * @param {string} [marketPairs] Comma-separated list of market pairs to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataFeedsApi
     */
    public marketDataFeedControllerGetMarketDataFeedSnapshot(id: string, period?: MarketDataFeedControllerGetMarketDataFeedSnapshotPeriodEnum, marketPairs?: string, options?: RawAxiosRequestConfig) {
        return MarketDataFeedsApiFp(this.configuration).marketDataFeedControllerGetMarketDataFeedSnapshot(id, period, marketPairs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a snapshot of market data for the default real price data
     * @param {MarketDataFeedControllerGetSnapshotPeriodEnum} [period] Time period for the snapshot
     * @param {string} [marketPairs] Comma-separated list of market pairs to filter by (e.g., SOL/USDC,BTC/USDC)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataFeedsApi
     */
    public marketDataFeedControllerGetSnapshot(period?: MarketDataFeedControllerGetSnapshotPeriodEnum, marketPairs?: string, options?: RawAxiosRequestConfig) {
        return MarketDataFeedsApiFp(this.configuration).marketDataFeedControllerGetSnapshot(period, marketPairs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a market data feed
     * @param {string} id Market data feed ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataFeedsApi
     */
    public marketDataFeedControllerRemove(id: string, options?: RawAxiosRequestConfig) {
        return MarketDataFeedsApiFp(this.configuration).marketDataFeedControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a market data feed
     * @param {string} id Market data feed ID
     * @param {UpdateMarketDataFeedDto} updateMarketDataFeedDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataFeedsApi
     */
    public marketDataFeedControllerUpdate(id: string, updateMarketDataFeedDto: UpdateMarketDataFeedDto, options?: RawAxiosRequestConfig) {
        return MarketDataFeedsApiFp(this.configuration).marketDataFeedControllerUpdate(id, updateMarketDataFeedDto, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const MarketDataFeedControllerGetMarketDataFeedSnapshotPeriodEnum = {
    Latest: 'latest',
    _1m: '1m',
    _5m: '5m',
    _15m: '15m',
    _30m: '30m',
    _1h: '1h',
    _4h: '4h',
    _12h: '12h',
    _1d: '1d',
    _1w: '1w'
} as const;
export type MarketDataFeedControllerGetMarketDataFeedSnapshotPeriodEnum = typeof MarketDataFeedControllerGetMarketDataFeedSnapshotPeriodEnum[keyof typeof MarketDataFeedControllerGetMarketDataFeedSnapshotPeriodEnum];
/**
 * @export
 */
export const MarketDataFeedControllerGetSnapshotPeriodEnum = {
    Latest: 'latest',
    _1m: '1m',
    _5m: '5m',
    _15m: '15m',
    _30m: '30m',
    _1h: '1h',
    _4h: '4h',
    _12h: '12h',
    _1d: '1d',
    _1w: '1w'
} as const;
export type MarketDataFeedControllerGetSnapshotPeriodEnum = typeof MarketDataFeedControllerGetSnapshotPeriodEnum[keyof typeof MarketDataFeedControllerGetSnapshotPeriodEnum];


/**
 * PortfoliosApi - axios parameter creator
 * @export
 */
export const PortfoliosApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new portfolio
         * @param {CreatePortfolioDto} createPortfolioDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioControllerCreate: async (createPortfolioDto: CreatePortfolioDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPortfolioDto' is not null or undefined
            assertParamExists('portfolioControllerCreate', 'createPortfolioDto', createPortfolioDto)
            const localVarPath = `/portfolios`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPortfolioDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all portfolios or filter by user ID
         * @param {string} [userId] Filter portfolios by user ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioControllerFindAll: async (userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/portfolios`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve details for a specific portfolio
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('portfolioControllerFindOne', 'id', id)
            const localVarPath = `/portfolios/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a portfolio
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('portfolioControllerRemove', 'id', id)
            const localVarPath = `/portfolios/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a portfolio\'s configuration
         * @param {string} id 
         * @param {UpdatePortfolioDto} updatePortfolioDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioControllerUpdate: async (id: string, updatePortfolioDto: UpdatePortfolioDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('portfolioControllerUpdate', 'id', id)
            // verify required parameter 'updatePortfolioDto' is not null or undefined
            assertParamExists('portfolioControllerUpdate', 'updatePortfolioDto', updatePortfolioDto)
            const localVarPath = `/portfolios/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePortfolioDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PortfoliosApi - functional programming interface
 * @export
 */
export const PortfoliosApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PortfoliosApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new portfolio
         * @param {CreatePortfolioDto} createPortfolioDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portfolioControllerCreate(createPortfolioDto: CreatePortfolioDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portfolioControllerCreate(createPortfolioDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfoliosApi.portfolioControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all portfolios or filter by user ID
         * @param {string} [userId] Filter portfolios by user ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portfolioControllerFindAll(userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PortfolioResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portfolioControllerFindAll(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfoliosApi.portfolioControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve details for a specific portfolio
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portfolioControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portfolioControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfoliosApi.portfolioControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a portfolio
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portfolioControllerRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portfolioControllerRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfoliosApi.portfolioControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a portfolio\'s configuration
         * @param {string} id 
         * @param {UpdatePortfolioDto} updatePortfolioDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portfolioControllerUpdate(id: string, updatePortfolioDto: UpdatePortfolioDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portfolioControllerUpdate(id, updatePortfolioDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfoliosApi.portfolioControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PortfoliosApi - factory interface
 * @export
 */
export const PortfoliosApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PortfoliosApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new portfolio
         * @param {CreatePortfolioDto} createPortfolioDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioControllerCreate(createPortfolioDto: CreatePortfolioDto, options?: RawAxiosRequestConfig): AxiosPromise<PortfolioResponseDto> {
            return localVarFp.portfolioControllerCreate(createPortfolioDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all portfolios or filter by user ID
         * @param {string} [userId] Filter portfolios by user ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioControllerFindAll(userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<PortfolioResponseDto>> {
            return localVarFp.portfolioControllerFindAll(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve details for a specific portfolio
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<PortfolioResponseDto> {
            return localVarFp.portfolioControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a portfolio
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioControllerRemove(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.portfolioControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a portfolio\'s configuration
         * @param {string} id 
         * @param {UpdatePortfolioDto} updatePortfolioDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioControllerUpdate(id: string, updatePortfolioDto: UpdatePortfolioDto, options?: RawAxiosRequestConfig): AxiosPromise<PortfolioResponseDto> {
            return localVarFp.portfolioControllerUpdate(id, updatePortfolioDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PortfoliosApi - object-oriented interface
 * @export
 * @class PortfoliosApi
 * @extends {BaseAPI}
 */
export class PortfoliosApi extends BaseAPI {
    /**
     * 
     * @summary Create a new portfolio
     * @param {CreatePortfolioDto} createPortfolioDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfoliosApi
     */
    public portfolioControllerCreate(createPortfolioDto: CreatePortfolioDto, options?: RawAxiosRequestConfig) {
        return PortfoliosApiFp(this.configuration).portfolioControllerCreate(createPortfolioDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all portfolios or filter by user ID
     * @param {string} [userId] Filter portfolios by user ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfoliosApi
     */
    public portfolioControllerFindAll(userId?: string, options?: RawAxiosRequestConfig) {
        return PortfoliosApiFp(this.configuration).portfolioControllerFindAll(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve details for a specific portfolio
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfoliosApi
     */
    public portfolioControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return PortfoliosApiFp(this.configuration).portfolioControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a portfolio
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfoliosApi
     */
    public portfolioControllerRemove(id: string, options?: RawAxiosRequestConfig) {
        return PortfoliosApiFp(this.configuration).portfolioControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a portfolio\'s configuration
     * @param {string} id 
     * @param {UpdatePortfolioDto} updatePortfolioDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfoliosApi
     */
    public portfolioControllerUpdate(id: string, updatePortfolioDto: UpdatePortfolioDto, options?: RawAxiosRequestConfig) {
        return PortfoliosApiFp(this.configuration).portfolioControllerUpdate(id, updatePortfolioDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new user
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerCreate: async (createUserDto: CreateUserDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUserDto' is not null or undefined
            assertParamExists('userControllerCreate', 'createUserDto', createUserDto)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFindAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a user by wallet public key
         * @param {string} publicKey Wallet public key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFindByPublicKey: async (publicKey: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'publicKey' is not null or undefined
            assertParamExists('userControllerFindByPublicKey', 'publicKey', publicKey)
            const localVarPath = `/users/by-public-key/{publicKey}`
                .replace(`{${"publicKey"}}`, encodeURIComponent(String(publicKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a user by ID
         * @param {string} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userControllerFindOne', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get portfolio ID for a user
         * @param {string} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetPortfolioByUserId: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userControllerGetPortfolioByUserId', 'id', id)
            const localVarPath = `/users/{id}/portfolio`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a user
         * @param {string} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userControllerRemove', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a user
         * @param {string} id User ID
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUpdate: async (id: string, updateUserDto: UpdateUserDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userControllerUpdate', 'id', id)
            // verify required parameter 'updateUserDto' is not null or undefined
            assertParamExists('userControllerUpdate', 'updateUserDto', updateUserDto)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new user
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerCreate(createUserDto: CreateUserDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerCreate(createUserDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerFindAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerFindAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a user by wallet public key
         * @param {string} publicKey Wallet public key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerFindByPublicKey(publicKey: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerFindByPublicKey(publicKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerFindByPublicKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a user by ID
         * @param {string} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get portfolio ID for a user
         * @param {string} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerGetPortfolioByUserId(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerGetPortfolioByUserId(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerGetPortfolioByUserId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a user
         * @param {string} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a user
         * @param {string} id User ID
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerUpdate(id: string, updateUserDto: UpdateUserDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerUpdate(id, updateUserDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new user
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerCreate(createUserDto: CreateUserDto, options?: RawAxiosRequestConfig): AxiosPromise<UserResponseDto> {
            return localVarFp.userControllerCreate(createUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFindAll(options?: RawAxiosRequestConfig): AxiosPromise<Array<UserResponseDto>> {
            return localVarFp.userControllerFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a user by wallet public key
         * @param {string} publicKey Wallet public key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFindByPublicKey(publicKey: string, options?: RawAxiosRequestConfig): AxiosPromise<UserResponseDto> {
            return localVarFp.userControllerFindByPublicKey(publicKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a user by ID
         * @param {string} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<UserResponseDto> {
            return localVarFp.userControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get portfolio ID for a user
         * @param {string} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetPortfolioByUserId(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.userControllerGetPortfolioByUserId(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a user
         * @param {string} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerRemove(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.userControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a user
         * @param {string} id User ID
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUpdate(id: string, updateUserDto: UpdateUserDto, options?: RawAxiosRequestConfig): AxiosPromise<UserResponseDto> {
            return localVarFp.userControllerUpdate(id, updateUserDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Create a new user
     * @param {CreateUserDto} createUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerCreate(createUserDto: CreateUserDto, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerCreate(createUserDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerFindAll(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a user by wallet public key
     * @param {string} publicKey Wallet public key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerFindByPublicKey(publicKey: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerFindByPublicKey(publicKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a user by ID
     * @param {string} id User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get portfolio ID for a user
     * @param {string} id User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerGetPortfolioByUserId(id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerGetPortfolioByUserId(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a user
     * @param {string} id User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerRemove(id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a user
     * @param {string} id User ID
     * @param {UpdateUserDto} updateUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerUpdate(id: string, updateUserDto: UpdateUserDto, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerUpdate(id, updateUserDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WalletsApi - axios parameter creator
 * @export
 */
export const WalletsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new wallet
         * @param {CreateWalletDto} createWalletDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletControllerCreate: async (createWalletDto: CreateWalletDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createWalletDto' is not null or undefined
            assertParamExists('walletControllerCreate', 'createWalletDto', createWalletDto)
            const localVarPath = `/wallets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWalletDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all wallets
         * @param {string} [userId] Filter wallets by user ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletControllerFindAll: async (userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/wallets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a wallet by ID
         * @param {string} id Wallet ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('walletControllerFindOne', 'id', id)
            const localVarPath = `/wallets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the latest snapshot for a wallet
         * @param {string} id Wallet ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletControllerGetLatestSnapshot: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('walletControllerGetLatestSnapshot', 'id', id)
            const localVarPath = `/wallets/{id}/snapshots/latest`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get snapshots within a time range for a wallet
         * @param {string} id Wallet ID
         * @param {string} from Start timestamp (ISO format)
         * @param {string} [to] End timestamp (ISO format)
         * @param {number} [limit] Maximum number of snapshots to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletControllerGetSnapshotsRange: async (id: string, from: string, to?: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('walletControllerGetSnapshotsRange', 'id', id)
            // verify required parameter 'from' is not null or undefined
            assertParamExists('walletControllerGetSnapshotsRange', 'from', from)
            const localVarPath = `/wallets/{id}/snapshots`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a wallet
         * @param {string} id Wallet ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('walletControllerRemove', 'id', id)
            const localVarPath = `/wallets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a wallet
         * @param {string} id Wallet ID
         * @param {UpdateWalletDto} updateWalletDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletControllerUpdate: async (id: string, updateWalletDto: UpdateWalletDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('walletControllerUpdate', 'id', id)
            // verify required parameter 'updateWalletDto' is not null or undefined
            assertParamExists('walletControllerUpdate', 'updateWalletDto', updateWalletDto)
            const localVarPath = `/wallets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateWalletDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WalletsApi - functional programming interface
 * @export
 */
export const WalletsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WalletsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new wallet
         * @param {CreateWalletDto} createWalletDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletControllerCreate(createWalletDto: CreateWalletDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletEntityDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.walletControllerCreate(createWalletDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletsApi.walletControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all wallets
         * @param {string} [userId] Filter wallets by user ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletControllerFindAll(userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WalletEntityDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.walletControllerFindAll(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletsApi.walletControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a wallet by ID
         * @param {string} id Wallet ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletEntityDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.walletControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletsApi.walletControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the latest snapshot for a wallet
         * @param {string} id Wallet ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletControllerGetLatestSnapshot(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletSnapshotResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.walletControllerGetLatestSnapshot(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletsApi.walletControllerGetLatestSnapshot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get snapshots within a time range for a wallet
         * @param {string} id Wallet ID
         * @param {string} from Start timestamp (ISO format)
         * @param {string} [to] End timestamp (ISO format)
         * @param {number} [limit] Maximum number of snapshots to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletControllerGetSnapshotsRange(id: string, from: string, to?: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WalletSnapshotResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.walletControllerGetSnapshotsRange(id, from, to, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletsApi.walletControllerGetSnapshotsRange']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a wallet
         * @param {string} id Wallet ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletControllerRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.walletControllerRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletsApi.walletControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a wallet
         * @param {string} id Wallet ID
         * @param {UpdateWalletDto} updateWalletDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletControllerUpdate(id: string, updateWalletDto: UpdateWalletDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletEntityDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.walletControllerUpdate(id, updateWalletDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletsApi.walletControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WalletsApi - factory interface
 * @export
 */
export const WalletsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WalletsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new wallet
         * @param {CreateWalletDto} createWalletDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletControllerCreate(createWalletDto: CreateWalletDto, options?: RawAxiosRequestConfig): AxiosPromise<WalletEntityDto> {
            return localVarFp.walletControllerCreate(createWalletDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all wallets
         * @param {string} [userId] Filter wallets by user ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletControllerFindAll(userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<WalletEntityDto>> {
            return localVarFp.walletControllerFindAll(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a wallet by ID
         * @param {string} id Wallet ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<WalletEntityDto> {
            return localVarFp.walletControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the latest snapshot for a wallet
         * @param {string} id Wallet ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletControllerGetLatestSnapshot(id: string, options?: RawAxiosRequestConfig): AxiosPromise<WalletSnapshotResponseDto> {
            return localVarFp.walletControllerGetLatestSnapshot(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get snapshots within a time range for a wallet
         * @param {string} id Wallet ID
         * @param {string} from Start timestamp (ISO format)
         * @param {string} [to] End timestamp (ISO format)
         * @param {number} [limit] Maximum number of snapshots to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletControllerGetSnapshotsRange(id: string, from: string, to?: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<WalletSnapshotResponseDto>> {
            return localVarFp.walletControllerGetSnapshotsRange(id, from, to, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a wallet
         * @param {string} id Wallet ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletControllerRemove(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.walletControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a wallet
         * @param {string} id Wallet ID
         * @param {UpdateWalletDto} updateWalletDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletControllerUpdate(id: string, updateWalletDto: UpdateWalletDto, options?: RawAxiosRequestConfig): AxiosPromise<WalletEntityDto> {
            return localVarFp.walletControllerUpdate(id, updateWalletDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WalletsApi - object-oriented interface
 * @export
 * @class WalletsApi
 * @extends {BaseAPI}
 */
export class WalletsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new wallet
     * @param {CreateWalletDto} createWalletDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletsApi
     */
    public walletControllerCreate(createWalletDto: CreateWalletDto, options?: RawAxiosRequestConfig) {
        return WalletsApiFp(this.configuration).walletControllerCreate(createWalletDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all wallets
     * @param {string} [userId] Filter wallets by user ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletsApi
     */
    public walletControllerFindAll(userId?: string, options?: RawAxiosRequestConfig) {
        return WalletsApiFp(this.configuration).walletControllerFindAll(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a wallet by ID
     * @param {string} id Wallet ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletsApi
     */
    public walletControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return WalletsApiFp(this.configuration).walletControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the latest snapshot for a wallet
     * @param {string} id Wallet ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletsApi
     */
    public walletControllerGetLatestSnapshot(id: string, options?: RawAxiosRequestConfig) {
        return WalletsApiFp(this.configuration).walletControllerGetLatestSnapshot(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get snapshots within a time range for a wallet
     * @param {string} id Wallet ID
     * @param {string} from Start timestamp (ISO format)
     * @param {string} [to] End timestamp (ISO format)
     * @param {number} [limit] Maximum number of snapshots to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletsApi
     */
    public walletControllerGetSnapshotsRange(id: string, from: string, to?: string, limit?: number, options?: RawAxiosRequestConfig) {
        return WalletsApiFp(this.configuration).walletControllerGetSnapshotsRange(id, from, to, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a wallet
     * @param {string} id Wallet ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletsApi
     */
    public walletControllerRemove(id: string, options?: RawAxiosRequestConfig) {
        return WalletsApiFp(this.configuration).walletControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a wallet
     * @param {string} id Wallet ID
     * @param {UpdateWalletDto} updateWalletDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletsApi
     */
    public walletControllerUpdate(id: string, updateWalletDto: UpdateWalletDto, options?: RawAxiosRequestConfig) {
        return WalletsApiFp(this.configuration).walletControllerUpdate(id, updateWalletDto, options).then((request) => request(this.axios, this.basePath));
    }
}



